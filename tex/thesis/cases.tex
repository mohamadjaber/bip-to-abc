%% searching studies with CBMC
The programs $\Pm_1$ and $\Pm_2$ in Figures~\ref{fig:linearsearch} and~\ref{fig:binarysearch}
show the linear search and binary search algorithms annotated with appropriate
preconditions and postconditions, respectively. The precondition in $\Pm_1$ ensures that 
the provided size $n$ is valid, \ie positive and smaller than the largest allowed array size. 
The precondition in $Pm_2$ checks that the provided size $n$ is valid and that the 
array $a$ is sorted in ascending order. 
The postcondition in both $\Pm_1$ and $\Pm_2$ 
checks that when the returned index $rv$ is between 0 and the size $n$, then 
array element at the index, $a[rv]$, is equal to the element $e$ to search for. It also 
checks that when $rv$ is invalid, the element $e$ is not present in the 
array $a$. 

We use \mytool{} and CBMC to verify that the programs $\Pm_1$ and $\Pm_2$ satisfy the 
precondition-postcondition pairs provided. We make use of the assume statement \cci{\_\_CPROVER\_assume}
in CBMC to implement the preconditions, and we encode the quantifiers as while loops. 
In \mytool{}, we use the dedicate property grammar and the FOL support to write the specifications. 
We implement the check $precondition \implies postcondition$ as an assertion statement
in CBMC.

\begin{figure}[bt]
\begin{Verbatim}[fontsize=\relsize{-1.0}, numbersep=4pt,numbers=left]
int ls (int [] a, int e, int n) {
  @pre ls {0 <= n && n <= MAX_ARRAY_SIZE}
  int i = 0;
  while (i < n) {
    if (a[i] == e)
      return i;
    i = i + 1;  
  }
  return -1;
  
  @post ls { (rv >= 0 && rv < n) -> (a[rv] == e) &&
    (rv == -1) -> (forall(int i:[0..n-1]) {a[i] != e})
  }
}
\end{Verbatim}
\caption{The linear search algorithm with pre and post conditions}
\label{fig:linearsearch}
\end{figure}

\begin{figure}[bt]
\begin{Verbatim}[fontsize=\relsize{-1.0}, numbersep=4pt,numbers=left]
int bs (int [] a, int e, int n) {
  @pre bs {0 <= n && n <= MAX_ARRAY_SIZE && isSorted(a,n)}
  int low = 0, high = n -1;
  while (low < high) {
    int mid = (low + high) >> 1;
    if (a[mid] < e) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  if ((low == high) && (a[low] == el)) {
    return low;
  } else {
    return -1;
  }
  
  @post bs { (rv >= 0 && rv < n) -> (a[rv] == e) &&
    (rv == -1) -> (forall(int i:[0..n-1]) {a[i] != e})
  }
}

isSorted(int [] a, int n) = forall(int i:[0..n-2]) {
  a[i] <= a[i+1]
}
\end{Verbatim}
\caption{The binary search algorithm with pre and post conditions}
\label{fig:binarysearch}
\end{figure}

We compare the results obtained from \mytool{} and CBMC in terms of the problem size and
verification time. The problem size is defined as the number of variables and clauses 
in the generated CNF formulae in CBMC, and the number of latches, AND gates and logic levels
in the generated AIGs in \mytool{}. We report on the size of the generated formulae and AIGs
after performing optimization and reduction steps in both CBMC and \mytool{}. We compare 
the time taken by both tools to perform all of the required steps to return a decision, 
including both optimization and verification.
Since CBMC supports only $16$, $32$ and $64$ bits scalars, we use the size of the input
array $a$ as the variable to change between different settings of the programs $\Pm_1$
and $\Pm_2$. We set a time-out limit of $30$ minutes and do not set a limit on the 
amount of memory the program can use (up to the machine's physical limit).

Note that in the addition to the above, CBMC requires users to provide an {\em unwinding
limit}. This limit is used by CBMC to unroll loops in the input programs $\Pm_1$ and $\Pm_2$.
We use an unwinding limit of $2\times array\_size$ for our experiments and we enable 
the CBMC unwinding assertions. \mytool{} does not require any unwinding limit since
it does not perform unrolling, it uses the program counter to execute the loops infinitely 
many times using the same AIG. 

Table~\ref{tb:cbmc_compare} shows the results of using \mytool{} and CBMC to verify the 
programs $\Pm_1$ and $\Pm_2$ for different sizes of the input array $a$, shown in the 
column {\em size}. The columns {\em Vars} and {\em Clauses} report on the size of the
CNF formula generated by CBMC in terms of the number of variables and clauses, respectively. 
The columns {\em lat}, {\em and} and {\em lev} show the size of the generated AIG by \mytool{}
in terms of the number of latches, and gates and logic levels, respectively. The last two columns
show the time taken by \mytool{} and CBMC to perform both reduction and verification. 
The {\em Time-out} entry indicates that the tool reached the time out limit before 
returning a conclusive result about the verification problem.

\input{table_comparison}

The results show that \mytool{} is able to verify the linear search program $\Pm_1$ 
for sizes much higher than those provided by CBMC. For array size of $15$ and above, \mytool{}
is able to efficiently generate the AIG, and call ABC to reduce and verify it, while CBMC
reached the time out limit without giving any decision. Also, the size of the generated AIG 
by \mytool{} is always smaller than the size of the CNF formula generated by CBMC.
For example, for an array size of $15$, CBMC's CNF formula contains $9112$ variables
and $34496$ clauses, while \mytool{}'s AIG has $119$ bit registers and $1116$ AND gates.
This clearly shows the advantage that the program counter encoding provides over 
loop unrolling. 

For the binary search program ($\Pm_2$), both tools show similar performance for sizes of $3$, $7$
and $15$. \mytool{} outperforms CBMC for a bound of $63$ since CBMC reached the time out limit
while \mytool{} was able to verify the program in $1152$ seconds. Similarly to $\Pm_1$, 
the size of the generated AIGs by \mytool{} is orders of magnitudes smaller than the size of the 
generated CNF formulae by CBMC. For example, for a size of $63$, the number of variables  
in the generated AIG is $99\%$ smaller than the number of variables in the generated CNF formula.