
%% the algorithm
\section{BIP to \caig}
\label{chap3:bip2aig:bip2etc}
Given a BIP system $\Pm = (B, Init, v)$, \biptool~translates \Pm into 
a \caig~program with its own customized execution engine. Function \cci{BIP-to-CAIG} takes a BIP system as input and constructs a \caig program. It calls four functions that fill \cci{decl-list}, \cci{wiredef-list}, \cci{init-list}, \cci{next-list}. All these function use the \cci{append} call to add code fragments to lists. 

\begin{lstlisting}
/*@\textbf{BIP-to-CAIG}@*/(B, Init, v)
  generateDeclartionList()
  generateWireDefList()
  generateInitList()
  generateNextList()
\end{lstlisting}

Function \cci{generateDeclartionList()} fills \cci{decl-list} as follows. 
It creates three arrays of wires to denote interaction semantics. Array $ie$ elements denote whether all logical constraints except priority rules are met for a given interaction. Array $ip$ elements denote whether a given interaction is enabled after applying priority rules. Array $is$ elements denote whether an enabled interaction is selected for execution. Currently, one interaction is selected to avoid executing conflicting interactions. Two interactions are conflicting if they involve same components. The $selector$ wire is a non-deterministic primary input that is used to select one of the enabled interactions. The $cycle$ boolean register is used to denote whether the system is executing actions corresponding to either interaction or transition. 
The function also declares two wires ($B_i.p_j.e$ and $B_i.p_j.s$) for each port $p_j$. Wire $B_i.p_j.e$ denotes whether the port is enabled and wire $B_i.p_j.s$ denotes whether the port is selected by the interaction for execution. Moreover, for each component $B_i$ the function declares a register variable $B_i.\ell$ denoting the current location of $B_i$. Similarly, the function declares a variable register $B_i.x_j$ for each variable $x_j$ in component $B_i$.  


\begin{lstlisting}
/*@\textbf{generateDeclartionList()}@*/
  // interaction enablement wires
  append $wire~bool~ie[|J|]$ to decl-list
  // interaction priority wires
  append $wire~bool~ip [ |J| ]$ to decl-list 
  // interaction selected wires
  append $wire~bool~is[|J|]$ to decl-list 
  // non-deterministic priority selector wire
  append $wire~int~selector$ to decl-list 
  // cycle denotes transition or interaction mode
  append $bool~cycle$ to decl-list  

  foreach $i \in [1..|I|]$
    foreach $j \in [1..|B_i.P|]$ 
      // port enablement
      append $wire~bool~B_i.p_j.e$ to  decl-list 
      // port selected
      append $wire~bool~B_i.p_j.s$ to  decl-list 
    endfor

    // location registers
    append $int~B_i.\ell$ to decl-list
    
    foreach $j \in [1..|B_i.X|]$ 
      // variable registers
      append $int~B_i.x_j$ to  decl-list 
    endfor
  endfor
\end{lstlisting}


Function \cci{generateWireDefList()} fills \cci{wiredef-list} with functional macro definitions as follows. The enable wire $B_i.p_j.e$ is \true when there exists a transition $\tau$ labeled with port $p$, its source ($\tau.src$) is the current location ($B_i.\ell$), and its guard is \true. 

Array element $ie[j]$ corresponding to interaction $a_j$ is evaluated to \true when the guard of $a_j$ is \true and all its ports are enabled. Array element $ip[j]$ is evaluated to \true when $ie[j]$ is \true and $a_j$ has higher priority than other enabled interactions. Array element $is[j]$ is evaluated to \true when $ip[j]$ is true either $a_j$ is selected ($selector$ equals to $j$) or the selected interaction is not enabled and $j$ is the first enabled interaction greater with an index greater than $j$. The use of non-deterministic selector is added for fairness. 
The selected wire $B_i.p_j.s$ is \true when there exists a selected interaction $a_k$ (i.e., $is[k]$ is \true) involving $B_i.p_j$.

 
\begin{lstlisting}
/*@\textbf{generateWireDefList()}@*/
  // iterate over components
  foreach $i \in [1..|I|]$ 
    // iterate over component ports
    foreach $j \in [1..|B_i.P|]$ 
      append $B_i.p_j.e := \bigvee_{\tau \in transitions(B_i.p_j)} \tau.guard \land B_i.\ell = \tau.src$ to  wiredef-list 
    endfor
  endfor
  
  // iterate over interactions
  foreach $j \in [1..|J|]$ 
    append $ie[j] := a_j.guard \wedge \bigwedge_{p\in a_i.P} component(p).p.e$ to  wiredef-list 
    append $ip[j] := ie[j] \wedge \,(\forall k \neq j: ie[k] \Rightarrow a_k < a_j)$ to  wiredef-list 
    append $is[j] := ip[j] \wedge \,(selector = j \vee (\lnot ip[selector] \land \forall k > j: \neg ip[k])$ to  wiredef-list 
  endfor
  
  // iterate over components
  foreach $i \in [1..|I|]$ 
    // iterate over component ports
    foreach $j \in [1..|B_i.P|]$ 
      append $B_i.p_j.s := \bigvee_{a_k \in interactions(B_i.p_j)} is[k]$ to  wiredef-list 
    endfor
  endfor
\end{lstlisting}

Function \cci{generateInitList()} fills \cci{init-list} with initial value definitions taken from $Init$ for location variables ($B_i.\ell)$ and $v$ for component variables ($B_i.x_j)$. Register variable $cycle$ is initialized to zero to denote an interaction execution mode. 

\begin{lstlisting}
/*@\textbf{generateInitList()}@*/
  // initialize to interaction mode
  append $cycle := 0$ to init-list 
  foreach $i \in [1..|I|]$
    append $B_i.\ell := Init.B_i$ to  init-list 
    foreach $j \in [1..|B_i.X|]$
      // v is the initial valuation
      append $B_i.x_j := v(B_i.x_j)$ to init-list  
    endfor
  endfor
\end{lstlisting}

Function \cci{generateInitList()} fills \cci{next-list} with the next state value definitions of register variables. Each component variable can be modified either in an interaction action or in a transition action. The value of variable $cycle$ makes this distinction. 

In the interaction mode ($cycle$ equals to zero), the function considers each assignment statement $\sigma$ from the action of interaction $a_j$. The function appends a conditional clause requiring the $a_k$ to be selected for execution so that the target variable $B_i.x_j$ of $\sigma$ is assigned to the expression of $\sigma$ ($\sigma.expr$). The sequence of conditional clauses form a nested ternary conditional expressions where the last expression retains the previous value of the variable. 

Similarly, in the transition mode ($cycle$ equals to one), the function considers each assignment statement $\sigma$ from the action of transition $\tau$. The function appends a conditional clause requiring the port of the transition $\tau$ to be selected for execution and the location of the component to be equal to the source of the transition. The target variable $B_i.x_j$ of $\sigma$ is assigned to the expression of $\sigma$ ($\sigma.expr$). 

In the transition mode, the function considers the current location of each component $B_i.\ell$ and appends a conditional clause requiring the transition source to be equal to the current location and the port of the transition to be selected. The expression corresponding to the conditional clause updates the current location to be the destination of the transition ($\tau.dest$).  In the interaction mode, the location retains its value. Finally, the $cycle$ variable is toggled. 

% The sequence of conditional clauses form a nested ternary conditional expressions where the last expression retains the previous value of the variable.
\begin{lstlisting}
/*@\textbf{generateNextList()}@*/ 
  // iterate over components - interaction-mode
  foreach $i \in [1..|I|]$ 
    // iterate over variables, where $\textcolor{darkgreen}{B_i.X = \{x_1, \ldots, l_{|B_i.X|}\}}$ 
    foreach $j \in [1..|B_i.X|]$ 
      // interaction mode
      append $B_i.x_j := cycle = 0?$ to var-st
      // iterate over interactions
      foreach $k \in [1..|J|]$ 
        // iterate over interaction assignments
        foreach $\sigma \in a_k.action$
          if($B_i.x_j = \sigma.term$)
            append $is[k]?\, \sigma.expr:$ to var-st
          endif
        endfor
      endfor
      // interaction mode and no data transfer for $\textcolor{darkgreen}{B_i.x_j}$
      append $B_i.x_j$: to var-st 
      
      
      // iterate over component transitions - transition-mode
      append $B_i.\ell := cycle = 0?\, B_i.\ell :$ to loc-st
      foreach $\tau \in B_i.T$ 
        // iterate over transition assignments
        foreach $\sigma \in \tau.action$
          if($B_i.x_j = \sigma.term$)
            append $(B_i.port(\tau).s \wedge \tau.src = B_i.\ell)?\, \sigma.expr:$ to var-st 
          endif
        endfor
        append $(B_i.port(\tau).s \wedge \tau.src = B_i.\ell)?\, \tau.dest:$ to loc-st 
      endfor  
      
      append $B_i.x_j$ to var-st 
      append var-st to  next-list 
      
      append $B_i.\ell$ to loc-st 
      append loc-st to  next-list 

    endfor
    // switch cycle
    append $cycle := \neg cycle$ to  next-list 
  endfor
\end{lstlisting}



\subsection{Illustrative Example}
Figure \ref{fig:traffic:bip} shows a traffic light controller system modeled in BIP. 
It is composed of two atomic components, \cci{timer} and \cci{light}. The timer counts
the amount of time for which the light must stay in a specific state (i.e. a specific
color of the light).
The light component determines the color of 
the traffic light. Additionally, it
informs the timer about the amount of time to spend in each 
location through a data transfer on the interaction $a$ between the two components. 

\begin{figure}[h!]
 \centering
 \resizebox{0.5\textwidth}{!}{
   \input{figures/traffic.pdf_t}
 }
 \caption{Traffic light in BIP}
 \label{fig:traffic:bip}
\end{figure}


Table~\ref{tb:bip:exec} shows a sample execution trace of \mytool's BIP engine
on the traffic light example presented in Figure~\ref{fig:traffic:bip}. The variables 
$timer.t$, $timer.n$, $timer.\ell$, $light.\ell$ and $light.m$ represent $t$, $n$
and the control location variable in the timer component, and the control location variable
and $m$ in the light component, respectively. 
We start at cycle $c$ where that state of the BIP system is $$\left(timer.t = 9, timer.n = 10,
timer.\ell = s_0, light.\ell = G, light.m = 3\right)$$
and we assume that the execution engine has picked the interaction involving the 
$timer$ port of the timer component has been selected and executed. 

At cycle $c+1$, the engine executes the internal transition in the timer component
that corresponds to the $timer.timer$ port being selected and the component is in location $s_0$. 
Therefore the variable $timer.t$ is incremented and the component 
remains in the same control location $s_0$. Since the light component
had no ports involved in the executed interaction, it will not change 
state. 

At cycle $c+2$, the guard $t \geq n$ is enabled and thus the $timer.done$ and $light.done$ ports are enabled. 
The engine selects the interaction connecting the two components
for execution. It executes the actions associated with this interaction 
and transfers the value of the variable $done.m$ to the variable $done.n$.

At cycle $c+3$, the engine executes the interaction transitions that 
correspond to the interaction executed at cycle $c+2$. In the timer 
component, the variable $timer.t$ is reset $0$ and the control location 
remains in location $s_0$. In the light component, the variable 
$light.m$ takes the value $5$ and the control location moves to location 
$Y$ corresponding to the yellow light being displayed. 

\begin{table}[bt]
\centering
\caption{Sample of \biptool{} execution}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
Cycle & $timer.t$ & $timer.n$ & $timer.\ell$ & $light.\ell$ & $light.m$ \\ 
\hline
$c$ & $9$ & $10$ & $s_0$ & $G$ & $3$ \\
		\hline
		$c+1$ & $10$ & $10$ & $s_0$ & $G$ & $3$ \\
			\hline
			$c+2$ & $10$ & $3$ & $s_0$ & $G$ & $3$ \\
				\hline
	 $c+3$ & $0$ & $3$ & $s_0$ & $Y$ & $5$ \\
	 \hline
\end{tabular}
\label{tb:bip:exec}
\end{table}

Listing~\ref{sample:code:bip} shows a code snippet from the code that \biptool{} generates
when applied to the traffic light controller BIP system shown in Figure~\ref{fig:traffic:bip}.
Lines 2 to 19 show the wire definitions for the system. The interaction 
labeled by $0$ corresponds to the interaction involving the $timer.timer$
port, while the interaction labeled $1$ correspond to the interaction 
involving the ports $timer.done$ and $light.done$. 
Interaction $0$ is enabled ($ie[0]$) when its guard is enabled ($true$ 
in this case) and the port $timer.timer$ that it involves is enabled, 
\ie{} the wire $timer.timer.e$ is set to $true$. 
Similarly, interaction $1$ is enabled ($ie[1]$) when its guard is
enabled and the ports $timer.done$ and $light.done$ are enabled 
($timer.done.e \land light.done.e$).

The wires $ip[0]$ and $ip[1]$ are asserted when each of the two interactions 
is prioritized. We assume in our case that interaction $1$ has a higher
priority, and thus interaction $0$ is only prioritized when it is enabled
and interaction $1$ is not. In any other case, it is interaction $1$ that
is prioritized by the engine. 

Furthermore, the wires $is[0]$ and $is[1]$ represent the execution of the 
engine's interaction selection procedure. The wire $selector$ is
a non-deterministic wire used by the engine to make non-deterministic
choices when several interactions are prioritized. 
The interaction $0$ is selected
when it is prioritized and either the non-deterministic selector 
selects it ($selector == 0$)
or the interaction $1$ is not prioritized. 
The interaction $1$ is selected when it is prioritized and either 
the selector selects it ($selector == 1$) or the selector wire
has selected an interaction that is not prioritized. Since interaction
$1$ has the largest index, it is
directly selected when the value of the selector corresponds
to an interaction that is not prioritized ($\lnot ip[selector]$).

The wires $component.port.e$ and $component.port.s$ represent the 
port enabled and selected wires, respectively. 
For example, the timer port 
in the timer component ($timer.timer.e$) is enabled when the 
component is in control location $s_0$ and the guard $timer.t < n$ is
enabled. Additionally, this port is selected when the interaction $0$ 
in which it is involved has been selected ($timer.timer.s = is[0]$).

Lines 21 to 38 show the next state functions for each of the variables
and control variables of the components of the system. 
In the first execution cycle ($cycle == 0$), 
the engine selects and executes interactions.
In the second execution cycle ($cycle == 1$), 
it executes internal transitions. 
When the interaction $1$ is selected ($is[1]$) and the engine is 
in its first cycle, the value of the variable $light.m$ is transfered
to the variable $timer.n$. Otherwise, $timer.n$ retains its current
value.

In the internal transition execution cycle, the next state value of
the variable $light.m$ is dictated by the control location at which the component is currently at, and whether the port $light.done$
is selected (equivalently the interaction $1$ has been selected).
For example, if the port $light.done$ is selected and the component 
is at the yellow light location ($Y$), the value of
$light.m$ will be 10. 

Finally, the control location variables $timer.\ell$ and 
$light.\ell$ are also updated according to the internal transitions of the 
atomic components. For example when the $light.done$ port is selected
and the light component is in the green control location ($G$), 
 $light.\ell$ moves from $G$ to $Y$. 

\begin{lstlisting}
/*** decl-List ***/
int timer.t;
int timer.n;
int light.m;
int timer.$\ell$;
int light.$\ell$;
bool cycle;

wire int selector;
wire bool timer.timer.e;
wire bool timer.timer.s;
wire bool timer.done.e;
wire bool timer.done.s;
wire bool light.done.e;
wire bool light.done.s;
wire bool[2] ie;
wire bool[2] ip;
wire bool[2] is;

/*** wiredef-list ***/
timer.timer.e = (0 == timer.$\ell$) && (timer.t < timer.n);
timer.done.e  = (0 == timer.$\ell$) && (timer.t == timer.n);
light.done.e  = (0 == light.$\ell$)  || (1 == light.$\ell$) || (2 == light.$\ell$);

ie[0] = timer.timer.e;
ie[1] = (light.done.e && timer.done.e);

ip[0] = ie[0];
ip[1] = ie[1];

is[0] = (ip[0] && ( selector == 0 || (!ip[selector]  && !ip[1]);
is[1] = (ip[1] && ( selector == 1 || (!ip[selector]);

timer.timer.e = is[0];
timer.done.e  = is[1];
light.done.e  = is[1] ;
   
do-together {
  /*** init-list ***/
  timer.t = 0; 
  timer.n = 10; 
  timer.$\ell$ = 0;
  light.m = 5; 
  light.$\ell$ = 0;
  cycle = true; 
}

while(true) {
  do-together {
    /*** next-list ***/    
    timer.n = cycle? is[1]? light.m : timer.n : timer.n; 
    
    timer.$\ell$ = (cycle? timer.$\ell$: timer.timer.e && timer.$\ell$ == 0? 0 : timer.timer.e && timer.$\ell$ == 0? 0 : timer.$\ell$;
    
    timer.t = cycle? timer.t : timer.$\ell$ == 0 && timer.timer.e? (timer.t + 1) : timer.$\ell$ == 0 && timer.done.e? 0 : 
              timer.t; 
              
    light.$\ell$ = cycle? light.$\ell$ : light.$\ell$ == 2 && light.done.e? 0: light.$\ell$ == 1 && light.done.e? 0 : light.$\ell$ == 0 
              && light.done.e? 1 : light.$\ell$; 
              
    light.m = cycle? light.m : light.$\ell$ == 0 && light.done.e? 3: light.$\ell$ == 1 && light.done.e? 10: light.$\ell$ == 2 
              && light.done.e? 5 : light.m; 
    
    cycle = !cycle;
  }
}
\end{lstlisting}
