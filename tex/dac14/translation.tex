
%% the algorithm
\section{BIP to \caig}
\label{sec:bip2aig}

Given a BIP system $\Pm = (B, Init, v)$, \biptool~
calls function  \cci{BIP-to-OLP} to translate \Pm into 
an \caig~program with its own customized execution engine. 
It calls four functions 
that fill \cci{decl-list}, \cci{wiredef-list}, \cci{init-list}, \cci{next-list}. 
All these function use the \cci{append} call to add code fragments to lists. 

\begin{lstlisting}
/*@\textbf{BIP-to-OLP}@*/(B, Init, v)
  generateDeclartionList()
  generateWireDefList()
  generateInitList()
  generateNextList()
\end{lstlisting}

Function \cci{generateDeclartionList()} fills \cci{decl-list} as follows. 
It creates three arrays of wires to denote interaction semantics. 
Array $ie$ elements denote whether all logical constraints except priority rules are met for a given interaction. 
Array $ip$ elements denote whether a given interaction is enabled after applying priority rules. 
Array $is$ elements denote whether an enabled interaction is selected for execution. 
Currently, one interaction is selected to avoid executing conflicting interactions. 
Two interactions are conflicting if they involve same components. 
The $selector$ wire is a non-deterministic primary input that is used to select one of the enabled interactions. 
The $cycle$ boolean register is used to denote whether the system is executing actions corresponding to either interaction or transition. 
The function also declares two wires ($B_i.p_j.e$ and $B_i.p_j.s$) for each port $p_j$. 
Wire $B_i.p_j.e$ denotes whether the port is enabled and wire $B_i.p_j.s$ denotes whether the port is selected by the interaction for execution. 
Moreover, for each component $B_i$ the function declares a register variable $B_i.\ell$ denoting the current location of $B_i$. 
Similarly, the function declares a variable register $B_i.x_j$ for each variable $x_j$ in component $B_i$.  

\begin{lstlisting}
/*@\textbf{generateDeclartionList()}@*/
  // interaction enablement wires
  append $wire~bool~ie[|J|]$ to decl-list
  // interaction priority wires
  append $wire~bool~ip [ |J| ]$ to decl-list 
  // interaction selected wires
  append $wire~bool~is[|J|]$ to decl-list 
  // non-deterministic priority selector wire
  append $wire~int~selector$ to decl-list 
  // cycle denotes transition or interaction mode
  append $bool~cycle$ to decl-list  

  foreach $i \in [1..|I|]$
    foreach $j \in [1..|B_i.P|]$ 
      // port enablement
      append $wire~bool~B_i.p_j.e$ to  decl-list 
      // port selected
      append $wire~bool~B_i.p_j.s$ to  decl-list 
    endfor

    // location registers
    append $int~B_i.\ell$ to decl-list
    
    foreach $j \in [1..|B_i.X|]$ 
      // variable registers
      append $int~B_i.x_j$ to  decl-list 
    endfor
  endfor
\end{lstlisting}


Function \cci{generateWireDefList()} fills \cci{wiredef-list} with functional macro definitions as follows. The enable wire $B_i.p_j.e$ is \true when there exists a transition $\tau$ labeled with port $p$, its source ($\tau.src$) is the current location ($B_i.\ell$), and its guard is \true. 

Array element $ie[j]$ corresponding to interaction $a_j$ is evaluated to \true when the guard of $a_j$ is \true and all its ports are enabled. Array element $ip[j]$ is evaluated to \true when $ie[j]$ is \true and $a_j$ has higher priority than other enabled interactions. Array element $is[j]$ is evaluated to \true when $ip[j]$ is true either $a_j$ is selected ($selector$ equals to $j$) or the selected interaction is not enabled and $j$ is the first enabled interaction greater with an index greater than $j$. The use of non-deterministic selector is added for fairness. 
The selected wire $B_i.p_j.s$ is \true when there exists a selected interaction $a_k$ (i.e., $is[k]$ is \true) involving $B_i.p_j$.

 
\begin{lstlisting}
/*@\textbf{generateWireDefList()}@*/
  // iterate over components
  foreach $i \in [1..|I|]$ 
    // iterate over component ports
    foreach $j \in [1..|B_i.P|]$ 
      append $B_i.p_j.e := \bigvee_{\tau \in transitions(B_i.p_j)} \tau.guard \land B_i.\ell = \tau.src$ to  wiredef-list 
    endfor
  endfor
  
  // iterate over interactions
  foreach $j \in [1..|J|]$ 
    append $ie[j] := a_j.guard \wedge \bigwedge_{p\in a_i.P} component(p).p.e$ to  wiredef-list 
    append $ip[j] := ie[j] \wedge \,(\forall k \neq j: ie[k] \Rightarrow a_k < a_j)$ to  wiredef-list 
    append $is[j] := ip[j] \wedge \,(selector = j \vee (\lnot ip[selector] \land \forall k > j: \neg ip[k])$ to  wiredef-list 
  endfor
  
  // iterate over components
  foreach $i \in [1..|I|]$ 
    // iterate over component ports
    foreach $j \in [1..|B_i.P|]$ 
      append $B_i.p_j.s := \bigvee_{a_k \in interactions(B_i.p_j)} is[k]$ to  wiredef-list 
    endfor
  endfor
\end{lstlisting}

Function \cci{generateInitList()} fills \cci{init-list} with initial value definitions taken from $Init$ for location variables ($B_i.\ell)$ and $v$ for component variables ($B_i.x_j)$. Register variable $cycle$ is initialized to zero to denote an interaction execution mode. 

\begin{lstlisting}
/*@\textbf{generateInitList()}@*/
  // initialize to interaction mode
  append $cycle := 0$ to init-list 
  foreach $i \in [1..|I|]$
    append $B_i.\ell := Init.B_i$ to  init-list 
    foreach $j \in [1..|B_i.X|]$
      // v is the initial valuation
      append $B_i.x_j := v(B_i.x_j)$ to init-list  
    endfor
  endfor
\end{lstlisting}

Function \cci{generateNextList()} fills \cci{next-list} with the next state value definitions of register variables. Each component variable can be modified either in an interaction action or in a transition action. The value of variable $cycle$ makes this distinction. 

In the interaction mode ($cycle$ equals to zero), the function considers each assignment statement $\sigma$ from the action of interaction $a_j$. The function appends a conditional clause requiring the $a_k$ to be selected for execution so that the target variable $B_i.x_j$ of $\sigma$ is assigned to the expression of $\sigma$ ($\sigma.expr$). The sequence of conditional clauses form a nested ternary conditional expressions where the last expression retains the previous value of the variable. 

Similarly, in the transition mode ($cycle$ equals to one), the function considers each assignment statement $\sigma$ from the action of transition $\tau$. The function appends a conditional clause requiring the port of the transition $\tau$ to be selected for execution and the location of the component to be equal to the source of the transition. The target variable $B_i.x_j$ of $\sigma$ is assigned to the expression of $\sigma$ ($\sigma.expr$). 

In the transition mode, the function considers the current location of each component $B_i.\ell$ and appends a conditional clause requiring the transition source to be equal to the current location and the port of the transition to be selected. The expression corresponding to the conditional clause updates the current location to be the destination of the transition ($\tau.dest$).  In the interaction mode, the location retains its value. Finally, the $cycle$ variable is toggled. 

% The sequence of conditional clauses form a nested ternary conditional expressions where the last expression retains the previous value of the variable.
\begin{lstlisting}
/*@\textbf{generateNextList()}@*/ 
  // iterate over components - interaction-mode
  foreach $i \in [1..|I|]$ 
    // iterate over variables, where $\textcolor{darkgreen}{B_i.X = \{x_1, \ldots, l_{|B_i.X|}\}}$ 
    foreach $j \in [1..|B_i.X|]$ 
      // interaction mode
      append $B_i.x_j := cycle = 0?$ to var-st
      // iterate over interactions
      foreach $k \in [1..|J|]$ 
        // iterate over interaction assignments
        foreach $\sigma \in a_k.action$
          if($B_i.x_j = \sigma.term$)
            append $is[k]?\, \sigma.expr:$ to var-st
          endif
        endfor
      endfor
      // interaction mode and no data transfer for $\textcolor{darkgreen}{B_i.x_j}$
      append $B_i.x_j$: to var-st 
      
      
      // iterate over component transitions - transition-mode
      append $B_i.\ell := cycle = 0?\, B_i.\ell :$ to loc-st
      foreach $\tau \in B_i.T$ 
        // iterate over transition assignments
        foreach $\sigma \in \tau.action$
          if($B_i.x_j = \sigma.term$)
            append $(B_i.port(\tau).s \wedge \tau.src = B_i.\ell)?\, \sigma.expr:$ to var-st 
          endif
        endfor
        append $(B_i.port(\tau).s \wedge \tau.src = B_i.\ell)?\, \tau.dest:$ to loc-st 
      endfor  
      
      append $B_i.x_j$ to var-st 
      append var-st to  next-list 
      
      append $B_i.\ell$ to loc-st 
      append loc-st to  next-list 

    endfor
    // switch cycle
    append $cycle := \neg cycle$ to  next-list 
  endfor
\end{lstlisting}



\subsection{Illustrative Example}
Figure \ref{fig:traffic:bip} shows a traffic light controller system modeled in BIP. 
It is composed of two atomic components, \cci{timer} and \cci{light}. The timer counts
the amount of time for which the light must stay in a specific state (i.e. a specific
color of the light). The light component determines the color of the traffic light. Additionally, it
informs the timer about the amount of time to spend in each location through a data transfer on the interaction between the two components. 

\begin{figure}[h!]
 \centering
 \resizebox{0.5\textwidth}{!}{
   \input{figures/traffic.pdf_t}
 }
 \caption{Traffic light in BIP}
 \label{fig:traffic:bip}
\end{figure}

Figure~\ref{fig:caigtraffic} shows $\caig$ code generated that corresponds to the  to the traffic light controller BIP system shown in Figure~\ref{fig:traffic:bip}. 
\input{figcaigtraffic}

\subsection{One cycle optimization}
Recall that an interaction specifies a strong synchronization among its involved components. Data transfer can take place during such synchronization. The operational semantic of BIP requires to (1) first execute data transfer of the selected interaction and then (2) execute the functions of the corresponding transitions of atomic components. For this, in the above translation, we used $cycle$ boolean register to denote whether the system is executing actions corresponding to either interaction or transition. However, in some cases data transfers of all interactions modify some variables that are not assigned in the corresponding transitions of those interactions. This can be detected by doing a static data dependency between interactions and their transitions. 
This may drastically improve the performance of the system since data transfers as well as functions of transitions may be executed in one cycle. Note that, our implementation supports this optimization.   

