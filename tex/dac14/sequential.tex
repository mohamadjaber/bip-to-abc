\section{Sequential Circuit}
\label{sec:preliminaries}
The ABC solver operates on an sequential circuit representation of a program.
\begin{definition}[Sequential circuit]
\rm A {\em sequential circuit} is a tuple $\big( (V, E),G,
O\big)$.  The pair $(V,E)$ represents a directed graph on
vertices $V$ and edges $E \subseteq V\times V$ where $E$
is a totally ordered relation.  The function $G: V \mapsto
{\mathit types}$ maps vertices to ${\mathit types}$.
There are three disjoint types: {\em primary inputs}, {\em
bit-registers} (which we often simply refer to as {\em
registers}), and logical {\em gates}.  Registers have designated
{\em initial values}, as well as {\em next-state
functions}.  Gates describe logical functions such as
the conjunction or disjunction of other vertices. 
A subset $O$ of $V$ is specified as the {\em
primary outputs} of $V$.  
We will denote the set of primary input variables by $I$,
and the set of bit-register variables by $R$.  
\label{def:back:seq_circuit}
\end{definition}

\begin{definition}[Fanins]
\rm We define the direct {\em fanin}s of a gate $u$ to be
$\{v \mid (v,u)\in E\}$ the set of source vertices connected
to $u$ in $E$.  We call the {\em support} of $u$ $\{v \mid
(v\in I \vee v \in R) \wedge (v,u) \in \ast E\}$ all
source vertices in $R$ or $I$ that are connected to $u$
with $\ast E$, the transitive closure of $E$.
\label{def:back:fanins} 
\end{definition}


For the sequential
circuit to be syntactically well-formed, vertices in $I$
should have no fanins, vertices in $R$ should have
2~fanins (the next-state function and the initial-value
function of that register), 
and every cycle in the sequential circuit should contain
at least one vertex from $R$.  
The initial-value functions
of $R$ shall have no registers in their support.  
All sequential circuits we consider will be well-formed.  

\subsection{Semantics of sequential circuits}
\label{s:back:crct_semantics}

\begin{definition}[State]
\rm A {\em state} is a Boolean valuation to vertices in $R$. 
%A {\em concrete input} is a Boolean valuation to vertices in $I$.
\end{definition}

\begin{definition}[Trace]
\rm A {\em trace} is a mapping $t: V \times \mathbb{N} \rightarrow
\mathbb{B}$ that assigns a valuation to all vertices in
$V$ across time {\em steps} denoted as indexes from
$\mathbb{N}$.  The mapping must be consistent with $E$ and
$G$ as follows.  Term $u_{j}$ denotes the source vertex of
the $j$-th incoming edge to $v$, implying that
$(u_{j},v)\in E$.  The value of gate $v$ at time $i$ in
trace $t$ is denoted by $t(v,i)$.
\[
t(v,i)=
   \begin{cases}
      s^i_{v}            &:v \in I \ \text{with sampled value $s_{v}^i$}\\
      t(u_1, 0)       &:v \in R,i=0,u_1:=\ \text{initial-state of $v$}\\
      t(u_2, i-1)        &:v \in R,i>0,u_2:=\ \text{next-state of $v$}\\
      G_v\big(t(u_{1},i),...,t(u_{n},i)\big) &: v \ \text{is a combinational gate with logical function 
$G_v$}
   \end{cases} \newline
\]
\end{definition}

The semantics of a sequential circuit are defined with
respect to semantical traces.  Given an input valuation
sequence and an initial state, the resulting trace is a
sequence of Boolean valuations to all vertices in $V$
which is consistent with the Boolean functions at the
gates.  We will refer to the transition from one valuation
to the next as a {\em step}.  A node in the circuit is
justifiable if there is an input sequence which when
applied to an initial state will result in that node
taking value $\mbox{true}$.  A node in the circuit is
valid if its negation is not justifiable.  We will refer
to targets and invariants in the circuit; these are simply
vertices in the circuit whose justifiability and validity
is of interest respectively.
A sequential circuit can naturally
be associated with a finite state machine (FSM),
which is a graph on the states.  However, the 
circuit is very different from its FSM; among
other differences, it is exponentially more succinct in
almost all cases of interest~\cite{BuClMcDiHw92}. 
%Figure~\ref{f:back:cctfsm}(a) shows a 2-bit write enabled 
%buffer which uses a multiplexer enabled by $w_{en}$ to 
%update its register bits $r$ with values in inputs $i$ 
%when $w_{en}$ is $1$ and retains its state otherwise.
%It also shows the corresponding FSM with no labels on
%transitions for clarity of exposition purposes.
%Figure~\ref{f:back:cctfsm}(b) shows a 3-bit version of 
%the same circuit with the corresponding FSM. 
%Only the arcs corresponding to state $000$ are shown for 
%clarity of exposition.

The ABC analyzer reasons about And-Inverted-Graph (AIG)
sequential circuits which are
sequential circuits with gates restricted to have 2~fanins.
Since NAND is functionally complete, this is not a limitation.  

\begin{comment}
\subsection{Illustrating sequential circuits with C++ 
    classes}
\label{sec:back:crct_cpp}

An alternative way to understand a sequential circuit is
to think of it as a set of communicating and concurrent
threads.  A sequential circuit is easily understood as a
concurrent C program with Boolean variables describing 
its states, and functions describing its output and
computation.

\begin{lstlisting}
Boolean registerVariables[];
Boolean done;
  
void initialState(Boolean inputs[]);
Boolean nextState(Boolean inputs[]);
Boolean outputFunction(Boolean inputs[]);

Boolean executeCircuit(Boolean inputs[]) {
  initialState(inputs);
  while(!done) {
    for (int i = 0; i < sizeofRegisterVariables; i++) 
      dotogether {
        registerVariables[i] = nextState(registerVariables, inputs); 
      }
    return outputFunction(registerVariables, inputs); 
  } 
} 
\end{lstlisting}

The register variables describe the state of the program along with the \cci{done} 
variable that denotes the completion of the computation.  
The sequential circuit also accepts primary input variables as parameters to its functions. 

The \cci{initialState} function assigns the initial
state of the sequential circuit by assigning values to its
register variables that are restricted to be combinational
functions of the \cci{inputs}.  The \cci{nextState}
function updates the state of the sequential circuit by
assigning values to the register variables that are
combinational functions of the \cci{inputs} and the
\cci{registerVariables} themselves.  The \cci{nextState} 
function performs the computational function of
the sequential circuit and assigns \cci{done} to a
$\mbox{true}$ value once it completes the computation.
The \cci{outputFunction} returns the result of the
computation. 

Note that a sequential circuit may have more than one
output function where some of these functions denote the
validity of the output.  The function
\cci{executeCircuit} calls the \cci{initialState}
function to initialize it and then calling
\cci{nextState} to perform the computation.  It then
returns the output of the computation via calling the
\cci{outputFunction}.  The \cci{while} in
\cci{executeCircuit} models time where each iteration
is a step. 
\end{comment}
